/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => ObsidianCanvasMOC2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/Graphing.ts
var import_crypto = require("crypto");
async function graph(canvasFile, nodeParent, options) {
  const { data: node, subnodes } = nodeParent;
  if (!subnodes) {
    return;
  }
  let subnodesFiltered = subnodes.filter((subnode) => subnode.data.type !== "text" || subnode.subnodes !== void 0);
  const { spacing, angleSpan, startingAngle, center, minRadius, noteWidth } = options;
  let subNodeCoordinates = calculateCoordinates(noteWidth, spacing, subnodesFiltered.length, angleSpan, startingAngle, minRadius);
  await app.vault.process(canvasFile, (data) => {
    let canvasData = JSON.parse(data);
    canvasData.nodes.push({
      ...node,
      x: center.x + node.getXOffset(),
      y: center.y + node.getYOffset()
    });
    for (let i = 0; i < subnodesFiltered.length; i++) {
      canvasData.nodes.push({
        ...subnodesFiltered[i].data,
        x: center.x + subNodeCoordinates[i].x + subnodesFiltered[i].data.getXOffset(),
        y: center.y + subNodeCoordinates[i].y + subnodesFiltered[i].data.getYOffset()
      });
      let fromSide, toSide;
      if (subNodeCoordinates[i].angle < Math.PI / 4 || subNodeCoordinates[i].angle > 7 * Math.PI / 4) {
        fromSide = "right";
        toSide = "left";
      } else if (subNodeCoordinates[i].angle < 3 * Math.PI / 4) {
        fromSide = "bottom";
        toSide = "top";
      } else if (subNodeCoordinates[i].angle < 5 * Math.PI / 4) {
        fromSide = "left";
        toSide = "right";
      } else {
        fromSide = "top";
        toSide = "bottom";
      }
      canvasData.edges.push({
        fromNode: node.id,
        toNode: subnodesFiltered[i].data.id,
        fromSide,
        toSide,
        id: (0, import_crypto.randomUUID)()
      });
    }
    return JSON.stringify(canvasData);
  });
  const nodeCoordinates = subnodesFiltered.map((subnode, index) => {
    return { node: subnode, coordinate: subNodeCoordinates[index] };
  });
  return nodeCoordinates;
}
var calculateCoordinates = (nodeWidth, nodeSpacing, numOfNodes, angleSpan, startingAngle, minRadius) => {
  let angleDiff;
  let r = minRadius;
  if (numOfNodes === 1) {
    angleDiff = 0;
  } else {
    angleDiff = angleSpan == 2 * Math.PI ? angleSpan / numOfNodes : angleSpan / (numOfNodes - 1);
    r = Math.sqrt(2) * (nodeSpacing + nodeWidth) / (2 * Math.sqrt(1 - Math.cos(angleDiff)));
    r < minRadius ? r = minRadius : r = r;
  }
  let coordinates = [];
  for (let i = 0; i < numOfNodes; i++) {
    let angle = (angleDiff * i + startingAngle) % (2 * Math.PI);
    const x = r * Math.cos(angle);
    const y = r * Math.sin(angle);
    coordinates.push({ x, y, angle });
  }
  return coordinates;
};

// src/ReadMOC.ts
var import_crypto2 = require("crypto");
var import_obsidian = require("obsidian");
var NodeTextData = class {
  constructor(text, width, height) {
    this.id = (0, import_crypto2.randomUUID)();
    this.type = "text";
    this.text = "# " + text;
    this.width = width;
    this.height = height;
  }
  getXOffset() {
    return -this.width / 2;
  }
  getYOffset() {
    return -this.height / 2;
  }
};
var NodeFileData = class {
  constructor(file, width, height) {
    this.id = (0, import_crypto2.randomUUID)();
    this.type = "file";
    this.width = 250;
    this.height = 250;
    this.file = file.path;
    this.width = width;
    this.height = height;
  }
  getXOffset() {
    return -this.width / 2;
  }
  getYOffset() {
    return -this.height / 2;
  }
};
var readMOC = (mocFile, settings) => {
  var _a, _b, _c;
  const fileCache = app.metadataCache.getFileCache(mocFile);
  if (!fileCache) {
    new import_obsidian.Notice("File cache not found");
    return;
  }
  const headings = (_a = fileCache.headings) == null ? void 0 : _a.slice().sort((a, b) => a.position.end.line - b.position.end.line);
  const nonEmbedLinks = (_b = fileCache.links) == null ? void 0 : _b.slice().sort((a, b) => a.position.end.line - b.position.end.line);
  const links = ((_c = fileCache.embeds) != null ? _c : []).slice().sort((a, b) => a.position.end.line - b.position.end.line).reduce((acc, curr) => {
    acc.push(curr);
    return acc;
  }, nonEmbedLinks);
  const baseNode = {
    data: new NodeFileData(mocFile, settings.noteWidth, settings.noteHeight)
  };
  if (headings !== void 0) {
    const linksNotUnderHeadings = links == null ? void 0 : links.filter((link) => link.position.end.line < headings[0].position.end.line);
    baseNode.subnodes = linksNotUnderHeadings == null ? void 0 : linksNotUnderHeadings.reduce((acc, link) => {
      const path = getPathFromLink(link.link, mocFile);
      if (!path) {
        return acc;
      }
      const linkFile = app.vault.getAbstractFileByPath(path);
      if (!linkFile) {
        return acc;
      }
      acc.push({ data: new NodeFileData(linkFile, settings.noteWidth, settings.noteHeight) });
      return acc;
    }, Array());
  } else {
    baseNode.subnodes = links == null ? void 0 : links.reduce((acc, link) => {
      const path = getPathFromLink(link.link, mocFile);
      if (!path) {
        return acc;
      }
      const linkFile = app.vault.getAbstractFileByPath(path);
      if (!linkFile) {
        return acc;
      }
      acc.push({ data: new NodeFileData(linkFile, settings.noteWidth, settings.noteHeight) });
      return acc;
    }, Array());
    return baseNode;
  }
  for (let i = 0; i < headings.length; i++) {
    const heading = headings[i];
    const filteredLinks = links == null ? void 0 : links.filter((link) => link.position.end.line > heading.position.end.line && (i == headings.length - 1 || link.position.end.line < headings[i + 1].position.end.line));
    const headingNode = {
      data: new NodeTextData(heading.heading, settings.headingWidth, settings.headingHeight),
      subnodes: filteredLinks == null ? void 0 : filteredLinks.reduce((acc, link) => {
        const path = getPathFromLink(link.link, mocFile);
        if (!path) {
          return acc;
        }
        let file = app.vault.getAbstractFileByPath(path);
        if (!file) {
          return acc;
        }
        acc.push({
          data: new NodeFileData(file, settings.noteWidth, settings.noteHeight)
        });
        return acc;
      }, Array())
    };
    if (filteredLinks && filteredLinks.length > 0) {
      if (!baseNode.subnodes) {
        baseNode.subnodes = [];
      }
      baseNode.subnodes.push(headingNode);
    }
  }
  console.log(baseNode);
  return baseNode;
};
var getPathFromLink = (link, mocFile) => {
  if (link.contains("#")) {
    link = link.substring(0, link.indexOf("#"));
  }
  const resolvedLink = app.metadataCache.resolvedLinks[mocFile.path];
  if (!resolvedLink) {
    return void 0;
  }
  const path = Object.keys(resolvedLink).find((value) => value.contains(link));
  return path;
};

// src/RegenerateModal.ts
var import_obsidian2 = require("obsidian");
var RegenerateModal = class extends import_obsidian2.Modal {
  constructor(app2, displayName, onRegenerate) {
    super(app2);
    this.onRegenerate = onRegenerate;
    this.displayName = displayName;
  }
  onOpen() {
    const { contentEl } = this;
    const submit = () => {
      this.close();
      this.onRegenerate();
    };
    this.titleEl.setText(`A canvas file with name: "${this.displayName}" already exists. Do you want to regenerate it?`);
    new import_obsidian2.Setting(contentEl).setName("Regenerate Canvas? The current file will be overwritten.").addButton((btn) => btn.setButtonText("Regenerate").setCta().onClick(submit)).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/SettingTab.ts
var import_obsidian3 = require("obsidian");
var SettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Obsidian Canvas MOC Settings" });
    this.generateSettings({
      containerEl,
      name: "Spacing",
      description: "The spacing between nodes; There may still be overlap, but this is the general spacing",
      value: this.plugin.settings.spacing,
      onChange: (value) => {
        this.plugin.settings.spacing = value;
      },
      defaultValue: DEFAULT_SETTINGS.spacing,
      placeholder: "Spacing in px"
    });
    this.generateSettings({
      containerEl,
      name: "Level One Minimum Radius",
      description: "The minimum radius of first level of the graph the graph; This will take effet when there are not enough nodes for the radius to be affected by spacing",
      value: this.plugin.settings.levelOneMinRadius,
      onChange: (value) => {
        this.plugin.settings.levelOneMinRadius = value;
      },
      defaultValue: DEFAULT_SETTINGS.levelOneMinRadius,
      placeholder: "Minimum radius in px"
    });
    this.generateSettings({
      containerEl,
      name: "Level Two Minimum Radius",
      description: "The minimum radius of second level of the graph the graph; This will take effet when there are not enough nodes for the radius to be affected by spacing",
      value: this.plugin.settings.levelTwoMinRadius,
      onChange: (value) => {
        this.plugin.settings.levelTwoMinRadius = value;
      },
      defaultValue: DEFAULT_SETTINGS.levelTwoMinRadius,
      placeholder: "Minimum radius in px"
    });
    this.generateSettings({
      containerEl,
      name: "Heading Width",
      description: "The width of the text/heading node",
      value: this.plugin.settings.headingWidth,
      onChange: (value) => {
        this.plugin.settings.headingWidth = value;
      },
      defaultValue: DEFAULT_SETTINGS.headingWidth,
      placeholder: "Heading width in px"
    });
    this.generateSettings({
      containerEl,
      name: "Heading Height",
      description: "The height of the text/heading node",
      value: this.plugin.settings.headingHeight,
      onChange: (value) => {
        this.plugin.settings.headingHeight = value;
      },
      defaultValue: DEFAULT_SETTINGS.headingHeight,
      placeholder: "Heading height in px"
    });
    this.generateSettings({
      containerEl,
      name: "Note Width",
      description: "The width of the note node",
      value: this.plugin.settings.noteWidth,
      onChange: (value) => {
        this.plugin.settings.noteWidth = value;
      },
      defaultValue: DEFAULT_SETTINGS.noteWidth,
      placeholder: "Note width in px"
    });
    this.generateSettings({
      containerEl,
      name: "Note Height",
      description: "The height of the note node",
      value: this.plugin.settings.noteHeight,
      onChange: (value) => {
        this.plugin.settings.noteHeight = value;
      },
      defaultValue: DEFAULT_SETTINGS.noteHeight,
      placeholder: "Note height in px"
    });
    this.generateSettings({
      containerEl,
      name: "Angle Span",
      description: "The angle span of the graph (when there are enough ntoes to take up the spread); This is the angle between the first and last node",
      value: this.plugin.settings.angleSpan,
      onChange: (value) => {
        this.plugin.settings.angleSpan = value;
      },
      defaultValue: DEFAULT_SETTINGS.angleSpan,
      placeholder: "Angle span in degrees"
    });
    this.generateSettings({
      containerEl,
      name: "Angle Span Small",
      description: "The angle span of the graph when there are only 2 nodes",
      value: this.plugin.settings.angleSpanSmall,
      onChange: (value) => {
        this.plugin.settings.angleSpanSmall = value;
      },
      defaultValue: DEFAULT_SETTINGS.angleSpanSmall,
      placeholder: "Angle span in degrees"
    });
  }
  generateSettings({ containerEl, name, description, placeholder, value, onChange, defaultValue }) {
    new import_obsidian3.Setting(containerEl).setName(name).setDesc(description).addText((text) => {
      var _a;
      text.setPlaceholder(placeholder).setValue((_a = value == null ? void 0 : value.toString()) != null ? _a : NaN.toString()).onChange(async (value2) => {
        const parsedValue = parseInt(value2) || defaultValue;
        onChange(parsedValue);
        await this.plugin.saveSettings();
      });
      text.inputEl.id = name;
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        onChange(defaultValue);
        await this.plugin.saveSettings();
        const input = document.getElementById(name);
        console.log(input);
        if (input) {
          input.value = defaultValue.toString();
        }
      });
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  spacing: 10,
  levelOneMinRadius: 450,
  levelTwoMinRadius: 300,
  headingWidth: 250,
  headingHeight: 100,
  noteWidth: 250,
  noteHeight: 250,
  angleSpan: 120,
  angleSpanSmall: 60
};
var ObsidianCanvasMOC2 = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.createCanvas = async (mocFile) => {
      var _a, _b;
      let defaultCanvasJSON = {
        edges: [],
        nodes: []
      };
      let canvasFile;
      let name = mocFile.name + " Canvas.canvas";
      try {
        canvasFile = await this.app.vault.create(name, JSON.stringify(defaultCanvasJSON));
      } catch (e) {
        console.log(e);
        new RegenerateModal(this.app, name, () => {
          let canvasFile2 = this.app.vault.getAbstractFileByPath(name);
          if (!canvasFile2) {
            new import_obsidian4.Notice("We just have an error lol idek. I thought the canvas file was not created, but then it was, but now I can't find it");
            return;
          }
          this.app.vault.delete(canvasFile2);
          this.createCanvas(mocFile);
        }).open();
        return;
      }
      const nodes = readMOC(mocFile, this.settings);
      if (!nodes) {
        new import_obsidian4.Notice("Could not read MOC file");
        return;
      }
      await this.app.workspace.getLeaf(true).openFile(canvasFile);
      const spacing = this.settings.spacing;
      const headingGraphResponse = await graph(canvasFile, nodes, {
        center: { x: 0, y: 0 },
        spacing,
        angleSpan: 2 * Math.PI,
        startingAngle: 0,
        minRadius: this.settings.levelOneMinRadius,
        noteWidth: this.settings.noteWidth
      });
      if (!headingGraphResponse) {
        new import_obsidian4.Notice("Could not graph");
        return;
      }
      for (const coordinate of headingGraphResponse) {
        let angleSpan;
        if (((_a = coordinate.node.subnodes) == null ? void 0 : _a.length) == 1) {
          angleSpan = 0;
        } else if (((_b = coordinate.node.subnodes) == null ? void 0 : _b.length) == 2) {
          angleSpan = this.settings.angleSpanSmall;
        } else {
          angleSpan = this.settings.angleSpan;
        }
        await graph(canvasFile, coordinate.node, {
          center: { x: coordinate.coordinate.x, y: coordinate.coordinate.y },
          spacing,
          startingAngle: (2 * Math.PI + coordinate.coordinate.angle - angleSpan * (Math.PI / 180) / 2) % (2 * Math.PI),
          angleSpan: angleSpan * (Math.PI / 180),
          minRadius: this.settings.levelTwoMinRadius,
          noteWidth: this.settings.noteWidth
        });
      }
    };
  }
  async onload() {
    this.loadSettings();
    this.addCommand({
      name: "Create Canvas",
      id: "create-canvas",
      callback: () => {
        let activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension != "md") {
          return;
        }
        this.createCanvas(activeFile);
      }
    });
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    console.log("Settings saved", this.settings);
  }
  onunload() {
  }
};
